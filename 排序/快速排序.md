## 6.6 快速排序

快速排序的工作原理是通过分治的方式来将一个数组排序。

主要分为以下三个过程：

1. 选取主元，将数列划分为两部分（要求保证相对大小关系）；
2. 递归到两个子序列中分别进行快速排序；
3. 不用合并，因为此时数列已经完全有序（因为是原地排序）。

快速排序是一种不稳定的排序算法。最优和平均时间复杂度为 $ O(n\log_2n)$ ，最坏时间复杂度为 $O(n^2)$（即在降序序列中选择首元素作为主元时会导致分割的区间不均匀）。

代码如下：

```c++
#include <iostream>
using namespace std;

int a[] = {3, 2, 2, 1, 0, 18, 15, 60, 41, 1, 78};
// 快速排序
void quick_sort(int a[], int l, int r) {
    // 随机选取主元（小优化）
    int p = a[rand() % (r - l) + l];
    int i = l, j = r - 1;
    // 将当前区间划分成两部分 a[l...i] <= p 且a[j...r] >= p
    while (i <= j) {
        // 寻找大于或等于主元的元素
        for (;i < r && a[i] < p;++i);
        // 寻找小于或等于主元的元素
        for (;j >= l && a[j] > p;--j);
        // 交换两元素
        if (i <= j) {
            swap(a[i], a[j]);
            ++i, --j;
        }
    }
    // 如果左侧或右侧区间有2个或2个以上的元素就继续排序
    if (j > l) quick_sort(a, l, j + 1); // 这样的区间[...)
    if (r - i > 1) quick_sort(a, i, r);
}

int main() {
    int n = sizeof(a) / sizeof(int);
    quick_sort(a, 0, n);
    for (int i = 0;i < n;++i) printf("%d ", a[i]);
    return 0;
}
```

快速排序稍微修改即可在 $O(n)$ 的时间复杂度找出第k大的元素（快选算法，有空再加入）。

过程演示：
![[附件/Peek 2023-10-20 15-09.gif]]